/*
 *
 * Copyright Â© 2021-2022 Dell Inc. or its subsidiaries. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *      http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

// Code generated by mockery v2.14.0. DO NOT EDIT.

package mocks

import (
	context "context"

	gofsutil "github.com/dell/gofsutil"

	mock "github.com/stretchr/testify/mock"

	time "time"
)

// UtilInterface is an autogenerated mock type for the UtilInterface type
type UtilInterface struct {
	mock.Mock
}

// BindMount provides a mock function with given fields: ctx, source, target, options
func (_m *UtilInterface) BindMount(ctx context.Context, source string, target string, options ...string) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, source, target)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...string) error); ok {
		r0 = rf(ctx, source, target, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeviceRescan provides a mock function with given fields: ctx, devicePath
func (_m *UtilInterface) DeviceRescan(ctx context.Context, devicePath string) error {
	ret := _m.Called(ctx, devicePath)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, devicePath)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FindFSType provides a mock function with given fields: ctx, mountpoint
func (_m *UtilInterface) FindFSType(ctx context.Context, mountpoint string) (string, error) {
	ret := _m.Called(ctx, mountpoint)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, mountpoint)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, mountpoint)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Format provides a mock function with given fields: ctx, source, target, fsType, options
func (_m *UtilInterface) Format(ctx context.Context, source string, target string, fsType string, options ...string) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, source, target, fsType)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, ...string) error); ok {
		r0 = rf(ctx, source, target, fsType, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FormatAndMount provides a mock function with given fields: ctx, source, target, fsType, options
func (_m *UtilInterface) FormatAndMount(ctx context.Context, source string, target string, fsType string, options ...string) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, source, target, fsType)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, ...string) error); ok {
		r0 = rf(ctx, source, target, fsType, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetDevMounts provides a mock function with given fields: ctx, dev
func (_m *UtilInterface) GetDevMounts(ctx context.Context, dev string) ([]gofsutil.Info, error) {
	ret := _m.Called(ctx, dev)

	var r0 []gofsutil.Info
	if rf, ok := ret.Get(0).(func(context.Context, string) []gofsutil.Info); ok {
		r0 = rf(ctx, dev)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]gofsutil.Info)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, dev)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDiskFormat provides a mock function with given fields: ctx, disk
func (_m *UtilInterface) GetDiskFormat(ctx context.Context, disk string) (string, error) {
	ret := _m.Called(ctx, disk)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, disk)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, disk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFCHostPortWWNs provides a mock function with given fields: ctx
func (_m *UtilInterface) GetFCHostPortWWNs(ctx context.Context) ([]string, error) {
	ret := _m.Called(ctx)

	var r0 []string
	if rf, ok := ret.Get(0).(func(context.Context) []string); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMountInfoFromDevice provides a mock function with given fields: ctx, devID
func (_m *UtilInterface) GetMountInfoFromDevice(ctx context.Context, devID string) (*gofsutil.DeviceMountInfo, error) {
	ret := _m.Called(ctx, devID)

	var r0 *gofsutil.DeviceMountInfo
	if rf, ok := ret.Get(0).(func(context.Context, string) *gofsutil.DeviceMountInfo); ok {
		r0 = rf(ctx, devID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gofsutil.DeviceMountInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, devID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMounts provides a mock function with given fields: ctx
func (_m *UtilInterface) GetMounts(ctx context.Context) ([]gofsutil.Info, error) {
	ret := _m.Called(ctx)

	var r0 []gofsutil.Info
	if rf, ok := ret.Get(0).(func(context.Context) []gofsutil.Info); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]gofsutil.Info)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMpathNameFromDevice provides a mock function with given fields: ctx, device
func (_m *UtilInterface) GetMpathNameFromDevice(ctx context.Context, device string) (string, error) {
	ret := _m.Called(ctx, device)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, device)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, device)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNVMeController provides a mock function with given fields: device
func (_m *UtilInterface) GetNVMeController(device string) (string, error) {
	ret := _m.Called(device)

	if len(ret) == 0 {
		panic("no return value specified for GetNVMeController")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (string, error)); ok {
		return rf(device)
	}
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(device)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(device)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSysBlockDevicesForVolumeWWN provides a mock function with given fields: ctx, volumeWWN
func (_m *UtilInterface) GetSysBlockDevicesForVolumeWWN(ctx context.Context, volumeWWN string) ([]string, error) {
	ret := _m.Called(ctx, volumeWWN)

	var r0 []string
	if rf, ok := ret.Get(0).(func(context.Context, string) []string); ok {
		r0 = rf(ctx, volumeWWN)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, volumeWWN)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IssueLIPToAllFCHosts provides a mock function with given fields: ctx
func (_m *UtilInterface) IssueLIPToAllFCHosts(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Mount provides a mock function with given fields: ctx, source, target, fsType, options
func (_m *UtilInterface) Mount(ctx context.Context, source string, target string, fsType string, options ...string) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, source, target, fsType)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, ...string) error); ok {
		r0 = rf(ctx, source, target, fsType, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MultipathCommand provides a mock function with given fields: ctx, timeout, chroot, arguments
func (_m *UtilInterface) MultipathCommand(ctx context.Context, timeout time.Duration, chroot string, arguments ...string) ([]byte, error) {
	_va := make([]interface{}, len(arguments))
	for _i := range arguments {
		_va[_i] = arguments[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, timeout, chroot)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration, string, ...string) []byte); ok {
		r0 = rf(ctx, timeout, chroot, arguments...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, time.Duration, string, ...string) error); ok {
		r1 = rf(ctx, timeout, chroot, arguments...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveBlockDevice provides a mock function with given fields: ctx, blockDevicePath
func (_m *UtilInterface) RemoveBlockDevice(ctx context.Context, blockDevicePath string) error {
	ret := _m.Called(ctx, blockDevicePath)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, blockDevicePath)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RescanSCSIHost provides a mock function with given fields: ctx, targets, lun
func (_m *UtilInterface) RescanSCSIHost(ctx context.Context, targets []string, lun string) error {
	ret := _m.Called(ctx, targets, lun)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, string) error); ok {
		r0 = rf(ctx, targets, lun)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ResizeFS provides a mock function with given fields: ctx, volumePath, devicePath, ppathDevice, mpathDevice, fsType
func (_m *UtilInterface) ResizeFS(ctx context.Context, volumePath string, devicePath string, ppathDevice string, mpathDevice string, fsType string) error {
	ret := _m.Called(ctx, volumePath, devicePath, ppathDevice, mpathDevice, fsType)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, string) error); ok {
		r0 = rf(ctx, volumePath, devicePath, ppathDevice, mpathDevice, fsType)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ResizeMultipath provides a mock function with given fields: ctx, deviceName
func (_m *UtilInterface) ResizeMultipath(ctx context.Context, deviceName string) error {
	ret := _m.Called(ctx, deviceName)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, deviceName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// TargetIPLUNToDevicePath provides a mock function with given fields: ctx, targetIP, lunID
func (_m *UtilInterface) TargetIPLUNToDevicePath(ctx context.Context, targetIP string, lunID int) (map[string]string, error) {
	ret := _m.Called(ctx, targetIP, lunID)

	var r0 map[string]string
	if rf, ok := ret.Get(0).(func(context.Context, string, int) map[string]string); ok {
		r0 = rf(ctx, targetIP, lunID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, int) error); ok {
		r1 = rf(ctx, targetIP, lunID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Unmount provides a mock function with given fields: ctx, target
func (_m *UtilInterface) Unmount(ctx context.Context, target string) error {
	ret := _m.Called(ctx, target)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, target)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ValidateDevice provides a mock function with given fields: ctx, source
func (_m *UtilInterface) ValidateDevice(ctx context.Context, source string) (string, error) {
	ret := _m.Called(ctx, source)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, source)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, source)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WWNToDevicePath provides a mock function with given fields: ctx, wwn
func (_m *UtilInterface) WWNToDevicePath(ctx context.Context, wwn string) (string, string, error) {
	ret := _m.Called(ctx, wwn)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, wwn)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 string
	if rf, ok := ret.Get(1).(func(context.Context, string) string); ok {
		r1 = rf(ctx, wwn)
	} else {
		r1 = ret.Get(1).(string)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, string) error); ok {
		r2 = rf(ctx, wwn)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

type mockConstructorTestingTNewUtilInterface interface {
	mock.TestingT
	Cleanup(func())
}

// NewUtilInterface creates a new instance of UtilInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewUtilInterface(t mockConstructorTestingTNewUtilInterface) *UtilInterface {
	mock := &UtilInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
